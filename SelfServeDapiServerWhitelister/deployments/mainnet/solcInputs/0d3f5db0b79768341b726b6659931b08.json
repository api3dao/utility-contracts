{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ISelfServeDapiServerWhitelister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"@api3/airnode-protocol-v1/contracts/dapis/interfaces/IDapiReader.sol\";\n\ninterface ISelfServeDapiServerWhitelister is IDapiReader {\n    function allowToReadDataFeedWithIdFor30Days(bytes32 dataFeedId, address reader)\n        external;\n\n    function allowToReadDataFeedWithDapiNameFor30Days(bytes32 dapiName, address reader)\n        external;\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/interfaces/IDapiReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDapiReader {\n    function dapiServer() external view returns (address);\n}\n\n/// @dev We use the part of the interface that will persist between\n/// DapiServer versions\ninterface IBaseDapiServer {\n    function readDataFeedWithId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readDataFeedWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n}\n"
    },
    "contracts/SelfServeDapiServerWhitelister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"@api3/airnode-protocol-v1/contracts/dapis/DapiReader.sol\";\nimport \"./interfaces/ISelfServeDapiServerWhitelister.sol\";\nimport \"@api3/airnode-protocol-v1/contracts/dapis/interfaces/IDapiServer.sol\";\nimport \"@api3/airnode-protocol-v1/contracts/whitelist/interfaces/IWhitelistWithManager.sol\";\n\ncontract SelfServeDapiServerWhitelister is\n    DapiReader,\n    ISelfServeDapiServerWhitelister\n{\n    constructor(address _dapiServer) DapiReader(_dapiServer) {}\n\n    function allowToReadDataFeedWithIdFor30Days(\n        bytes32 dataFeedId,\n        address reader\n    ) public override {\n        (uint64 expirationTimestamp, ) = IDapiServer(dapiServer)\n            .dataFeedIdToReaderToWhitelistStatus(dataFeedId, reader);\n        uint64 targetedExpirationTimestamp = uint64(block.timestamp + 30 days);\n        if (targetedExpirationTimestamp > expirationTimestamp) {\n            IWhitelistWithManager(dapiServer).extendWhitelistExpiration(\n                dataFeedId,\n                reader,\n                targetedExpirationTimestamp\n            );\n        }\n    }\n\n    function allowToReadDataFeedWithDapiNameFor30Days(\n        bytes32 dapiName,\n        address reader\n    ) external override {\n        allowToReadDataFeedWithIdFor30Days(\n            keccak256(abi.encodePacked(dapiName)),\n            reader\n        );\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/DapiReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IDapiReader.sol\";\n\n/// @title Contract to be inherited by contracts that will read from a\n/// DapiServer contract\ncontract DapiReader is IDapiReader {\n    /// @notice DapiServer contract address\n    address public override dapiServer;\n\n    /// @param _dapiServer DapiServer contract address\n    constructor(address _dapiServer) {\n        setDapiServer(_dapiServer);\n    }\n\n    /// @notice Called internally to update the DapiServer contract address\n    /// @dev Inheriting contracts are highly recommended to expose this\n    /// functionality to be able to migrate between DapiServer contracts.\n    /// Otherwise, when the DapiServer goes out of service for any reason,\n    /// the dependent contract will go defunct.\n    /// Since this is a critical action, it needs to be protected behind\n    /// mechanisms such as decentralized governance, timelocks, etc.\n    /// @param _dapiServer DapiServer contract address\n    function setDapiServer(address _dapiServer) internal {\n        require(_dapiServer != address(0), \"dAPI server address zero\");\n        dapiServer = _dapiServer;\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/interfaces/IDapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../protocol/interfaces/IAirnodeRequester.sol\";\n\ninterface IDapiServer is IAirnodeRequester {\n    event SetRrpBeaconUpdatePermissionStatus(\n        address indexed sponsor,\n        address indexed rrpBeaconUpdateRequester,\n        bool status\n    );\n\n    event RequestedRrpBeaconUpdate(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address airnode,\n        bytes32 templateId\n    );\n\n    event RequestedRrpBeaconUpdateRelayed(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address airnode,\n        address relayer,\n        bytes32 templateId\n    );\n\n    event UpdatedBeaconWithRrp(\n        bytes32 indexed beaconId,\n        bytes32 requestId,\n        int256 value,\n        uint256 timestamp\n    );\n\n    event RegisteredBeaconUpdateSubscription(\n        bytes32 indexed subscriptionId,\n        address airnode,\n        bytes32 templateId,\n        bytes parameters,\n        bytes conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    );\n\n    event UpdatedBeaconWithPsp(\n        bytes32 indexed beaconId,\n        bytes32 subscriptionId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedBeaconWithSignedData(\n        bytes32 indexed beaconId,\n        int256 value,\n        uint256 timestamp\n    );\n\n    event UpdatedBeaconSetWithBeacons(\n        bytes32 indexed beaconSetId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedBeaconSetWithSignedData(\n        bytes32 indexed dapiId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event AddedUnlimitedReader(address indexed unlimitedReader);\n\n    event SetDapiName(\n        bytes32 indexed dapiName,\n        bytes32 dataFeedId,\n        address indexed sender\n    );\n\n    function setRrpBeaconUpdatePermissionStatus(\n        address rrpBeaconUpdateRequester,\n        bool status\n    ) external;\n\n    function requestRrpBeaconUpdate(\n        address airnode,\n        bytes32 templateId,\n        address sponsor\n    ) external returns (bytes32 requestId);\n\n    function requestRrpBeaconUpdateRelayed(\n        address airnode,\n        bytes32 templateId,\n        address relayer,\n        address sponsor\n    ) external returns (bytes32 requestId);\n\n    function fulfillRrpBeaconUpdate(\n        bytes32 requestId,\n        uint256 timestamp,\n        bytes calldata data\n    ) external;\n\n    function registerBeaconUpdateSubscription(\n        address airnode,\n        bytes32 templateId,\n        bytes memory conditions,\n        address relayer,\n        address sponsor\n    ) external returns (bytes32 subscriptionId);\n\n    function conditionPspBeaconUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external view returns (bool);\n\n    function fulfillPspBeaconUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconSetWithBeacons(bytes32[] memory beaconIds)\n        external\n        returns (bytes32 beaconSetId);\n\n    function updateBeaconSetWithBeaconsAndReturnCondition(\n        bytes32[] memory beaconIds,\n        uint256 updateThresholdInPercentage\n    ) external returns (bool);\n\n    function conditionPspBeaconSetUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external returns (bool);\n\n    function fulfillPspBeaconSetUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconSetWithSignedData(\n        address[] memory airnodes,\n        bytes32[] memory templateIds,\n        uint256[] memory timestamps,\n        bytes[] memory data,\n        bytes[] memory signatures\n    ) external returns (bytes32 beaconSetId);\n\n    function addUnlimitedReader(address unlimitedReader) external;\n\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId) external;\n\n    function dapiNameToDataFeedId(bytes32 dapiName)\n        external\n        view\n        returns (bytes32);\n\n    function readDataFeedWithId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readDataFeedValueWithId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value);\n\n    function readDataFeedWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readDataFeedValueWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value);\n\n    function readerCanReadDataFeed(bytes32 dataFeedId, address reader)\n        external\n        view\n        returns (bool);\n\n    function dataFeedIdToReaderToWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function dataFeedIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function deriveBeaconId(address airnode, bytes32 templateId)\n        external\n        pure\n        returns (bytes32 beaconId);\n\n    function deriveBeaconSetId(bytes32[] memory beaconIds)\n        external\n        pure\n        returns (bytes32 beaconSetId);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DAPI_NAME_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function HUNDRED_PERCENT() external view returns (uint256);\n\n    function dapiNameSetterRole() external view returns (bytes32);\n\n    function sponsorToRrpBeaconUpdateRequesterToPermissionStatus(\n        address sponsor,\n        address updateRequester\n    ) external view returns (bool);\n\n    function subscriptionIdToBeaconId(bytes32 subscriptionId)\n        external\n        view\n        returns (bytes32);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/interfaces/IWhitelistWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRolesWithManager.sol\";\n\ninterface IWhitelistWithManager is IWhitelistRolesWithManager {\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    function extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) external;\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/protocol/interfaces/IAirnodeRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAirnodeRequester {\n    function airnodeProtocol() external view returns (address);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/interfaces/IWhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRoles.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\ninterface IWhitelistRolesWithManager is\n    IWhitelistRoles,\n    IAccessControlRegistryAdminnedWithManager\n{\n    function whitelistExpirationExtenderRole() external view returns (bytes32);\n\n    function whitelistExpirationSetterRole() external view returns (bytes32);\n\n    function indefiniteWhitelisterRole() external view returns (bytes32);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/interfaces/IWhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWhitelistRoles {\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function INDEFINITE_WHITELISTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryAdminned.sol\";\n\ninterface IAccessControlRegistryAdminnedWithManager is\n    IAccessControlRegistryAdminned\n{\n    function manager() external view returns (address);\n\n    function adminRole() external view returns (bytes32);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/interfaces/IAccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryUser.sol\";\n\ninterface IAccessControlRegistryAdminned is IAccessControlRegistryUser {\n    function adminRoleDescription() external view returns (string memory);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/interfaces/IAccessControlRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAccessControlRegistryUser {\n    function accessControlRegistry() external view returns (address);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}